# Check for Cargo Availability — End-to-end flow

This document describes, step-by-step, what happens when the "Check for cargo availability" button is pressed in the UI and how the trading engine fulfils the request.

Overview

- High-level entry point:
   - Trading UI: [`scripts/ui/TradingUIEventHandlers.js`](scripts/ui/TradingUIEventHandlers.js) (handler: `_onCheckAvailability` delegates to `BuyingFlow.onCheckAvailability`)

Preconditions

- The module is initialized and datasets are loaded (see [`scripts/main.js`](scripts/main.js:753) and [`scripts/data-manager.js`](scripts/data-manager.js:789)).
- A settlement is selected in the UI and a season is set (or defaults to spring).

Step-by-step execution

1) UI event — user clicks the "Check for cargo availability" button
   - The click is handled by `_onCheckAvailability()` inside [`scripts/ui/TradingUIEventHandlers.js`](scripts/ui/TradingUIEventHandlers.js); this immediately delegates to `BuyingFlow.onCheckAvailability()`.
   - The UI handler collects current inputs: selected settlement name, selected season, optional cargo filters, actor context, and any test roll options.

2) UI input validation & preparation
   - `BuyingFlow.onCheckAvailability()` validates the selection using local helpers (e.g., `validateSettlementWithFeedback` in [`scripts/trading-application-v2.js`](scripts/trading-application-v2.js)).
   - If invalid, the UI shows validation errors and aborts.

3) Availability workflow selection
   - The handler first checks whether `this.cargoAvailabilityPipeline` is available (it is provided by `DataManager.getCargoAvailabilityPipeline()` during app bootstrapping).
   - When the pipeline exists, `BuyingFlow` keeps the already-selected settlement object and season and proceeds with the pipeline-first path (see Step 4).
   - When the pipeline is unavailable or throws, `BuyingFlow` falls back to `tradingEngine.performCompleteAvailabilityCheck(settlement, season, rollFunction)` (see Step 5). That call internally resolves settlement data through `_resolveSettlement()` in [`scripts/trading-engine.js`](scripts/trading-engine.js).

4) Pipeline execution (primary path)
   - `BuyingFlow` performs a market availability roll using Foundry's `Roll('1d100')` and posts it to chat when allowed.
   - `CargoAvailabilityPipeline.run({ settlement, season })` produces the slot plan, merchants, pricing, and metadata (`scripts/cargo-availability-pipeline.js`).
   - The UI converts each slot into renderable cargo entries, pairing them with merchants generated by `tradingEngine.generateRandomMerchant()`.
   - Pipeline results are treated as automatically available cargo (the roll is logged for transparency but does not veto slots in the current orange-realism pipeline).

5) TradingEngine fallback (legacy-compatible path)
   - If the pipeline is missing or fails, `BuyingFlow` calls `tradingEngine.performCompleteAvailabilityCheck()`.
   - `checkCargoAvailability()` inside the engine resolves the settlement, evaluates the engine-level pipeline feature flag, and either generates an availability plan or defers to `_legacyCheckCargoAvailability()`.
   - `TradingEngine.generateAvailabilityPlan({ settlement, season, forceRefresh })` (when enabled) discovers the pipeline in this order: reuse `this.pipeline` → `pipelineFactory` → `dataManager.getCargoAvailabilityPipeline()` → `safeRequire('./cargo-availability-pipeline.js')` → `window.CargoAvailabilityPipeline` (`scripts/trading-engine.js`). Discovery failures set `pipelineStatus = 'unavailable'` and trigger the legacy path.

6) TradingEngine pipeline run (fallback scenario)
   - When `pipelineEnabled` remains true inside the engine, `generateAvailabilityPlan()` orchestrates the pipeline steps internally (mirroring the standalone pipeline in [`scripts/cargo-availability-pipeline.js`](scripts/cargo-availability-pipeline.js)).
   - `_ensureDataLoaded`, `_buildSettlementContext`, `_calculateCargoSlots`, `_buildCandidateTable`, and `_processSlot` execute in the same order, producing a raw availability plan.
   - If the engine cannot produce a plan (flag disabled, discovery failure, or runtime error), it falls back to `_legacyCheckCargoAvailability()` and skips to Step 8 with no `plan` data.

7) Plan standardization & caching (engine pipeline only)
   - `TradingEngine._standardiseAvailabilityPlan(rawPlan, settlement, season)` normalizes plan shape and slot entries (`scripts/trading-engine.js`).
   - Plans are cached in `planCache` using `_buildPlanCacheKey()`, which concatenates the normalized season with an identifier resolved from `id → _id → uuid → key → name`. Missing identifiers throw. Cache entries persist until `forceRefresh` is requested or `setCurrentSeason()` clears the cache.

8) Availability chance estimation
    - `TradingEngine._estimateAvailabilityChance(slotPlan, settlement)` returns:
       - `slotPlan.calculatedChance` if present;
       - otherwise `slotPlan.chance` if present;
       - otherwise `TradingEngine.calculateAvailabilityChance(settlement)` which uses `(sizeNumeric + wealthRating) × 10` capped at 100 (see [`scripts/trading-engine.js`](scripts/trading-engine.js:233)).

9) Dice roll for availability
    - `TradingEngine` performs a d100 roll:
       - If the caller passed a `rollFunction`, the engine awaits it; both synchronous and Promise-returning implementations are supported in `_legacyCheckCargoAvailability`, `_processAvailabilityPlan`, and `_rollCargoMultiplier`.
       - Otherwise `_processAvailabilityPlan` currently calls `rollAvailability(chance)` which forwards to `rollDice('1d100')`. Because `rollAvailability` expects a settlement object, this path throws without a custom `rollFunction`; legacy paths still call `rollDice('1d100')`, using Foundry's `Roll` class when available and `rollDiceFallback()` otherwise (`scripts/trading-engine.js`:1383-1411).
    - Dice results and decisions are logged via `scripts/debug-logger.js`.

10) Availability decision
      - The engine evaluates `available = (plan.slots.length > 0) && (roll <= chance)`.
      - The result includes: `available`, `chance`, `roll`, `rollResult`, `settlement`, `slotPlan`, `candidateTable`, and the full `plan` (`scripts/trading-engine.js`:428).

11) Determine cargo types (Step 2A)
      - If a plan with `slots` exists, `determineCargoTypes(settlement, season, { plan })` extracts cargoType names and deduplicates them (`scripts/trading-engine.js`:570).
      - Otherwise `_legacyDetermineCargoTypes()` maps settlement production categories and handles seasonal trade cargo.

12) Calculate cargo size (Step 2B)
      - `calculateCargoSize(settlement, rollFunction, { plan, season })` is called:
         - If `plan.slotPlan` provides overrides (`sizeMultiplier`, `multiplier`, or `totalSize`) the engine applies them.
         - Otherwise `_rollCargoMultiplier({ rollFunction, isTrade })` executes:
            - Perform 1d100 (or two rolls if the trade bonus applies) and round up to the nearest 10 to obtain a multiplier (e.g., 73 -> 80).
            - `multiplier × (sizeNumeric + wealthRating)` yields total Encumbrance Points.
         - Returns detailed breakdown including roll results and the `tradeBonus` flag (`scripts/trading-engine.js`:836).

13) Final result assembly
      - `performCompleteAvailabilityCheck()` aggregates the availability result, cargo types, and cargo size into a single structure returned to the UI (`scripts/trading-engine.js`:937).

14) UI rendering & side-effects
      - UI receives the result and calls rendering code:
         - Trading application: rendering helpers in [`scripts/ui/TradingUIRenderer.js`](scripts/ui/TradingUIRenderer.js).
         - Availability results renderer: [`scripts/availability-results-renderer.js`](scripts/availability-results-renderer.js:6).
      - The UI shows:
         - Availability badge (available/unavailable)
         - Rolled result and target chance (legacy path) or logged market roll (pipeline path)
         - Candidate cargo types and sample merchants (from pipeline slots or `plan.candidateTable`)
         - Estimated cargo size in EP and summary breakdown (legacy path relies on `cargoSize.totalSize`)
         - Action buttons for buying (partial/all), reroll/desperation, or open merchant cards
      - Chat posting respects the `chatVisibility` setting (`game.settings.get('trading-places', 'chatVisibility')`). A value of `gm` whispers to the GM; `all` broadcasts. `TradingEngine.postChatMessage()` attempts Foundry's `ChatMessage.create` and falls back to a simple object in non-Foundry tests (`scripts/trading-engine.js`:1495, [`scripts/trading-application-v2.js`](scripts/trading-application-v2.js:626)).

15) Logging, persistence & hooks
      - Every step logs decisions and calculations via `WFRPDebugLogger` (`scripts/debug-logger.js`:72).
      - Successful plan generation sets `pipelineStatus = 'ready'` and caches the plan; failures set `pipelineStatus = 'error'` and rely on the logger (integrations may also populate `lastPipelineError`).
      - Hooks/events are triggered where appropriate (e.g., season changes call `Hooks.callAll("trading-places.seasonChanged", ...)`) via [`scripts/data-manager.js`](scripts/data-manager.js:1411).

Error handling & fallback paths

- `BuyingFlow.onCheckAvailability()` guards the UI pipeline call in a `try/catch`; when `CargoAvailabilityPipeline.run()` rejects, it logs via `_logError` and immediately executes the engine fallback path.
- `generateAvailabilityPlan()` logs errors, sets `pipelineStatus = 'error'`, and returns `null`, causing the engine to fall back to `_legacyCheckCargoAvailability()` (`scripts/trading-engine.js`:461-483).
- If dice rolling via Foundry fails, `rollDiceFallback()` is used to ensure deterministic behaviour (`scripts/trading-engine.js`:1411).
- Validation errors bubble up to the UI where `fallback-dialogs-v2.js` may present recovery dialogs.

Key files and functions (quick reference)

- UI handlers:
   - [`scripts/ui/TradingUIEventHandlers.js`](scripts/ui/TradingUIEventHandlers.js) — wires button clicks and forwards to flows
   - [`scripts/flow/BuyingFlow.js`](scripts/flow/BuyingFlow.js) — implements `_onCheckAvailability`
- Engine:
   - [`scripts/trading-engine.js`](scripts/trading-engine.js) — `checkCargoAvailability`, `performCompleteAvailabilityCheck`, and pipeline helpers
- Pipeline:
   - [`scripts/cargo-availability-pipeline.js`](scripts/cargo-availability-pipeline.js) — `generatePlan` and helpers
- Data layer:
   - [`scripts/data-manager.js`](scripts/data-manager.js) — settlement lookups and pipeline access
- Logging & errors:
   - [`scripts/debug-logger.js`](scripts/debug-logger.js)
   - [`scripts/error-handler.js`](scripts/error-handler.js)

Pipeline lifecycle details

- `DataManager.getCargoAvailabilityPipeline()` caches a single `CargoAvailabilityPipeline` instance and shares it with both the UI and the trading engine (`scripts/data-manager.js`).
- `generateAvailabilityPlan()` may return `null` when the pipeline flag is off, discovery fails, the pipeline throws, or the plan fails validation. In every case the legacy algorithm is used.
- Plan fragments (`slotPlan`, `candidateTable`, `slots`) are optional; callers must guard against `plan === null` or partial plans.
- Diagnostics should review `pipelineStatus`, cached plans in `planCache`, optional `lastPipelineError`, and logger output.
- When a `rollFunction` is supplied, `forceRefresh` is set to `true` so the plan cache is bypassed for deterministic rerolls.
- `checkCargoAvailability()` routes to `_legacyCheckCargoAvailability()` when the pipeline flag is false and `options.plan` is omitted, short-circuits to `_processAvailabilityPlan()` when `options.plan` is provided, and otherwise executes the pipeline path with legacy fallback (`scripts/trading-engine.js`:268-358).

Roll function contract

- `rollFunction` arguments can be synchronous or return Promises; the engine awaits promise-like results in `_legacyCheckCargoAvailability`, `_processAvailabilityPlan`, `_processCargoSizePlan`, and `_rollCargoMultiplier`.
- Trade settlements still trigger the second roll in `_rollCargoMultiplier`, regardless of whether the supplied roll function is sync or async.
- `_processAvailabilityPlan` currently forwards the numeric `chance` into `rollAvailability()`, which expects a settlement object. Provide a custom `rollFunction` when exercising the pipeline until that call signature is corrected.
- Dice rolls without Foundry fall back to `rollDiceFallback()`, yielding deterministic objects suitable for tests.

Returned object shapes

- `checkCargoAvailability()` returns `{ available, chance, roll, rollResult, settlement, slotPlan?, candidateTable?, plan? }`. Example: availabilityResult = { available: true, chance: 65, roll: 34, settlement: 'Altdorf', slotPlan: {...}, candidateTable: [...], plan: {...} }.
- `performCompleteAvailabilityCheck()` returns `{ available, availabilityCheck, cargoTypes, cargoSize }`. Example: completeResult = { available: true, availabilityCheck: availabilityResult, cargoTypes: ['Grain', 'Wool'], cargoSize: { totalSize: 640, sizeMultiplier: 80 } }.

Deterministic testing helpers

- Mock pipeline example: pipeline.generatePlan = () => ({ slots: [{ cargoType: 'Grain' }], slotPlan: { calculatedChance: 55, sizeMultiplier: 80 } }).
- Async roll function example: rollFunction = async () => 42.
- Pipeline failure fallback: pipeline.generatePlan = () => { throw new Error('boom'); } to assert the legacy path is used.

Chat posting behaviour

- `TradingEngine.postChatMessage()` attempts `ChatMessage.create()` and falls back to `{ content, speaker, type, posted: true, fallback: true }` when Foundry APIs are absent (`scripts/trading-engine.js`:1495).
- UI integrations read `chatVisibility` to decide whether messages whisper to GMs or broadcast to all players (see [`scripts/trading-application-v2.js`](scripts/trading-application-v2.js:626)).

Example unit test checklist

- Pipeline success with deterministic plan and synchronous rollFunction.
- Pipeline error that forces `_legacyCheckCargoAvailability()`.
- Trade settlement cargo size with double-roll multiplier handling.

References

- Core implementation: [`scripts/trading-engine.js`](scripts/trading-engine.js)
- Pipeline implementation: [`scripts/cargo-availability-pipeline.js`](scripts/cargo-availability-pipeline.js)
- UI entry points: [`scripts/ui/TradingUIEventHandlers.js`](scripts/ui/TradingUIEventHandlers.js), [`scripts/flow/BuyingFlow.js`](scripts/flow/BuyingFlow.js)